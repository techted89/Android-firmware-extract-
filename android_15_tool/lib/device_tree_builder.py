import os
import shutil
import glob

from android_15_tool.lib.boot_image import BootImage
from android_15_tool.lib.super_unpacker import SuperUnpacker
from android_15_tool.lib.unsparse import SparseImage
from android_15_tool.lib.twrp_device_tree import create_twrp_device_tree, generate_twrp_fstab
from android_15_tool.lib.scanner import MagicScanner
from android_15_tool.lib.erofs_parser import ErofsParser
from android_15_tool.lib.twrp_builder import generate_twrp_build_script


class DeviceTreeBuilder:
    """
    Orchestrates the process of building a TWRP device tree from firmware files.
    """

    def __init__(self, firmware_dir, output_dir):
        self.firmware_dir = firmware_dir
        self.output_dir = output_dir
        self.temp_dir = os.path.join(output_dir, "temp")
        self.device_tree_dir = os.path.join(output_dir, "device_tree")
        self.root_dir = os.path.join(self.device_tree_dir, "root")
        self.firmware_files = {}

    def build(self):
        """
        Executes the full device tree building process.
        """
        print("Starting TWRP device tree build process...")
        self._setup_directories()
        self._discover_firmware_files()
        self._combine_sparse_chunks()
        self._extract_and_assemble()
        self._unpack_partition_filesystems()

        fstab_files = self._find_fstab_files()
        if fstab_files:
            generate_twrp_fstab(fstab_files, self.device_tree_dir)
        else:
            print("Warning: No fstab files found.")

        if "super" in self.firmware_files:
            create_twrp_device_tree(self.firmware_files["super"], self.device_tree_dir)
        else:
            print("Warning: super.img not found, skipping BoardConfig.mk generation.")

        self._generate_proprietary_files_manifest()
        self._generate_extract_files_script()
        self._generate_build_scripts()

        print(f"Device tree build process complete. Output at: {self.device_tree_dir}")

    def _generate_extract_files_script(self):
        """
        Generates the extract-files.sh script.
        """
        print("Generating extract-files.sh script...")
        script_path = os.path.join(self.device_tree_dir, "extract-files.sh")

        script_content = \"\"\"#!/bin/bash
set -e

# This script is generated by android_15_tool.
# It copies proprietary files from an extracted firmware dump.

if [ -z "$1" ]; then
    echo "Usage: $0 /path/to/extracted/root/directory"
    exit 1
fi

EXTRACTED_ROOT="$1"
DEVICE_TREE_ROOT=$(dirname "$0")

cd "$DEVICE_TREE_ROOT"

echo "Copying proprietary files..."

while IFS= read -r file; do
    # Create the directory structure for the file
    mkdir -p "$(dirname "$file")"

    # Check if the source file exists before copying
    if [ -f "$EXTRACTED_ROOT/$file" ]; then
        # Copy the file from the source
        cp "$EXTRACTED_ROOT/$file" "$file"
    else
        echo "Warning: Missing file $EXTRACTED_ROOT/$file"
    fi
done < proprietary-files.txt

echo "Done."
\"\"\"
        with open(script_path, "w") as f:
            f.write(script_content)

        os.chmod(script_path, 0o755)
        print(f"extract-files.sh generated at: {script_path}")

    def _generate_proprietary_files_manifest(self):
        """
        Scans the extracted filesystem and generates a proprietary files manifest.
        """
        print("Generating proprietary files manifest...")
        manifest_path = os.path.join(self.device_tree_dir, "proprietary-files.txt")

        proprietary_paths = [
            "vendor/lib",
            "vendor/lib64",
            "vendor/firmware",
            "vendor/etc",
            "system/vendor/lib",
            "system/vendor/lib64",
            "system/vendor/firmware",
            "system/vendor/etc",
        ]

        with open(manifest_path, "w") as f:
            for prop_path in proprietary_paths:
                full_path = os.path.join(self.root_dir, prop_path)
                if os.path.exists(full_path):
                    for root, _, files in os.walk(full_path):
                        for file in files:
                            relative_path = os.path.relpath(os.path.join(root, file), self.root_dir)
                            f.write(f"{relative_path}\n")

        print(f"Proprietary files manifest generated at: {manifest_path}")

    def _get_android_version(self):
        """
        Finds and parses the build.prop file to determine the Android version.
        """
        build_prop_path = os.path.join(self.root_dir, "system", "build.prop")
        if not os.path.exists(build_prop_path):
            build_prop_path = os.path.join(self.root_dir, "vendor", "build.prop")
            if not os.path.exists(build_prop_path):
                return None, None

        with open(build_prop_path, "r") as f:
            for line in f:
                if "ro.build.version.release" in line:
                    release = line.split("=")[1].strip()
                if "ro.build.version.sdk" in line:
                    sdk = line.split("=")[1].strip()

        return release, sdk

    def _generate_build_scripts(self):
        """
        Generates the necessary build scripts for TWRP.
        """
        android_version, _ = self._get_android_version()
        if android_version:
            generate_twrp_build_script(self.device_tree_dir, android_version)
        else:
            print("Warning: Could not determine Android version, using default TWRP branch.")
            generate_twrp_build_script(self.device_tree_dir, "9.0")

    def _setup_directories(self):
        """
        Creates the necessary output and temporary directories.
        """
        if not os.path.exists(self.temp_dir):
            os.makedirs(self.temp_dir)
        if not os.path.exists(self.root_dir):
            os.makedirs(self.root_dir)

    def _discover_firmware_files(self):
        """
        Scans the firmware directory to find all relevant firmware files.
        """
        print("Discovering firmware files...")
        for file in os.listdir(self.firmware_dir):
            if file.startswith("super.img_sparsechunk"):
                if "super_sparse" not in self.firmware_files:
                    self.firmware_files["super_sparse"] = []
                self.firmware_files["super_sparse"].append(os.path.join(self.firmware_dir, file))
            elif file.endswith(".img"):
                name = os.path.splitext(file)[0]
                self.firmware_files[name] = os.path.join(self.firmware_dir, file)

        # Sort sparse chunks to ensure correct order
        if "super_sparse" in self.firmware_files:
            self.firmware_files["super_sparse"].sort()

    def _find_fstab_files(self):
        """
        Finds fstab files in the root directory.
        """
        fstab_files = []
        for root, _, files in os.walk(self.root_dir):
            for file in files:
                if file.startswith("fstab"):
                    fstab_files.append(os.path.join(root, file))
        return fstab_files

    def _unpack_partition_filesystems(self):
        """
        Unpacks the filesystems of the extracted partition images.
        """
        print("Unpacking partition filesystems...")
        super_out_dir = os.path.join(self.temp_dir, "super")
        for partition_img in os.listdir(super_out_dir):
            if not partition_img.endswith(".img"):
                continue

            partition_path = os.path.join(super_out_dir, partition_img)
            scanner = MagicScanner()
            image_types = scanner.identify_image(partition_path)

            if "EROFS Filesystem" in image_types:
                print(f"Unpacking EROFS filesystem: {partition_img}")
                staging_dir = os.path.join(self.temp_dir, os.path.splitext(partition_img)[0])
                parser = ErofsParser(partition_path)
                parser.extract(staging_dir)

                # Merge the extracted files into the root directory
                shutil.copytree(staging_dir, self.root_dir, dirs_exist_ok=True)

    def _extract_and_assemble(self):
        """
        Extracts firmware images and assembles the device tree.
        """
        print("Extracting and assembling device tree...")
        for name, path in self.firmware_files.items():
            if name == "super":
                self._extract_super(path)
            elif name in ["boot", "vendor_boot", "recovery", "init_boot"]:
                self._extract_boot(path)

    def _extract_super(self, super_img_path):
        """
        Extracts the super.img file and copies fstab files.
        """
        print(f"Extracting {super_img_path}...")
        super_out_dir = os.path.join(self.temp_dir, "super")
        unpacker = SuperUnpacker(super_img_path)
        unpacker.unpack(super_out_dir)

    def _extract_boot(self, boot_img_path):
        """
        Extracts a boot/recovery image and copies key components.
        """
        print(f"Extracting {boot_img_path}...")
        boot_out_dir = os.path.join(self.temp_dir, os.path.basename(boot_img_path))
        boot_image = BootImage(boot_img_path)
        boot_image.unpack(boot_out_dir)

        for item in ["kernel", "ramdisk", "dtb"]:
            item_path = os.path.join(boot_out_dir, item)
            if os.path.exists(item_path):
                shutil.copy(item_path, self.device_tree_dir)

    def _combine_sparse_chunks(self):
        """
        Combines sparse super.img chunks into a single raw image file.
        """
        if "super_sparse" not in self.firmware_files:
            return

        print("Combining sparse super.img chunks...")
        raw_super_path = os.path.join(self.temp_dir, "super.img")

        # Use the unsparse tool to combine the chunks
        sparse_image = SparseImage(self.firmware_files["super_sparse"][0])
        sparse_image.unsparse(raw_super_path)

        self.firmware_files["super"] = raw_super_path
